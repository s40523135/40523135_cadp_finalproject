{"pages":[{"title":"About","text":"2017Fall 機械設計工程系 CADP & CP 課程倉儲: https://mde1a1.kmol.info/2017fall 課程投影片: https://mde1a1.kmol.info/2017fall/doc/trunk/index.html 課程網誌: https://mde1a1.kmol.info/2017fall/doc/trunk/blog/","tags":"misc","url":"./pages/about/"},{"title":"2018 協同產品設計齒輪練習","text":"window.onload=function(){ // 設定 data/py 為共用程式路徑 brython({debug:1, pythonpath:['./../data/py']}); } # 將 導入的 document 設為 doc 主要原因在於與舊程式碼相容 from browser import document as doc # 由於 Python3 與 Javascript 程式碼已經不再混用, 因此來自 Javascript 的變數, 必須居中透過 window 物件轉換 from browser import window import math # 主要用來取得畫布大小 canvas = doc[\"cango_gear\"] # 此程式採用 Cango Javascript 程式庫繪圖, 因此無需 ctx ctx = canvas.getContext(\"2d\") cango = window.Cango.new # 針對變數的轉換, shapeDefs 在 Cango 中資料型別為變數, 可以透過 window 轉換 shapedefs = window.shapeDefs # 目前 Cango 結合 Animation 在 Brython 尚無法運作, 此刻只能繪製靜態圖形 # in CangoAnimation.js #interpolate1 = window.interpolate # Cobi 與 createGearTooth 都是 Cango Javascript 程式庫中的物件 #cobj = window.Cobj.new shape = window.Shape.new path = window.Path.new creategeartooth = window.createGearTooth.new tweener = window.Tweener.new # 經由 Cango 轉換成 Brython 的 cango, 指定將圖畫在 id=\"cango_gear\" 的 canvas 上 cgo = cango(\"cango_gear\") ###################################### # 畫正齒輪輪廓 ##################################### def cangoGear(n, m, pa): # n 為齒數 #n = 17 # pa 為壓力角 #pa = 25 # m 為模數, 根據畫布的寬度, 計算適合的模數大小 # Module = mm of pitch diameter per tooth #m = 0.8*canvas.width/n # pr 為節圓半徑 pr = n*m/2 # gear Pitch radius # generate gear data = creategeartooth(m, n, pa) # Brython 程式中的 print 會將資料印在 Browser 的 console 區 #print(data) gearTooth = shape(data, { \"fillColor\":\"#ddd0dd\", \"border\": True, \"strokeColor\": \"#606060\" }) gearTooth.rotate(180/n) # rotate gear 1/2 tooth to mesh # 單齒的齒形資料經過旋轉後, 將資料複製到 gear 物件中 gear = gearTooth.dup() # gear 為單一齒的輪廓資料 #cgo.render(gearTooth) # 利用單齒輪廓旋轉, 產生整個正齒輪外形 for i in range(1, n): # 將 gearTooth 中的資料複製到 newTooth newTooth = gearTooth.dup() # 配合迴圈, newTooth 的齒形資料進行旋轉, 然後利用 appendPath 方法, 將資料併入 gear newTooth.rotate(360*i/n) # appendPath 為 Cango 程式庫中的方法, 第二個變數為 True, 表示要刪除最前頭的 Move to SVG Path 標註符號 gear.appendPath(newTooth, True) # trim move command = True # 建立軸孔 # add axle hole, hr 為 hole radius hr = 0.6*pr # diameter of gear shaft shaft = path(shapedefs.circle(hr)) shaft.revWinding() gear.appendPath(shaft) # retain the 'moveTo' command for shaft sub path # setup the animation # backlash (mm) bklsh = 0.04*m # centre shift to make backlash dC = bklsh/(2*math.tan(math.pi*pa/180)) # np 為小齒輪齒數 np = 20 # gear ratio gr = n/np gearConfig = {'cx':-pr, 'cy':0, 'degs':[0, 360]} # gr*0.666 rpm #pinionConfig = {'cx':pr+dC, 'cy':0, 'degs':[0, -gr*360]} # 0.666 rpm # 目前並非以 tweener 執行動畫 #twnr = tweener(0, 90000, \"loop\") return gear # 設定兩齒齒數 n = 10 n2 = 10 reduced_ratio = 0.5 # 使用 80% 的畫布寬度 m = 0.5*canvas.width/((n+n2)*reduced_ratio) # 設定共同的壓力角 pa = 25 # n 齒輪的節圓半徑 pr = n*m/2 # n2 齒輪的節圓半徑 pr2 = n2*m/2 # 建立 gear gear = cangoGear(n, m, pa) cx = canvas.width/2 cy = canvas.height/2 #gear.translate(cx, cy) # render 繪出靜態正齒輪輪廓 #cgo.render(gear) # 利用 gear 資料複製一份, 命名為 gear1 #gear1 = gear.dup() # 建立 gear1 gear1 = cangoGear(n2, m, pa) from time import time from browser.timer import request_animation_frame as raf from browser.timer import set_interval deg = math.pi/180 def draw(): cgo.clearCanvas() gear.rotate(2*deg) # 在特定位置, 以特定 scale, 特定 degs 執行 render # 設定囓合點在畫布正中央 # 囓合點往左偏 pr/2 即為 n 齒輪的圓心 x 座標 #cgo.render(gear, {'x':cx-pr*reduced_ratio, 'y':cy, 'scl':reduced_ratio, 'degs':0}) cgo.render(gear, {'x':cx-(pr+pr2)*reduced_ratio, 'y':cy, 'scl':0.5, 'degs':0}) # 根據兩齒輪齒數比決定 n2 齒輪轉速 gear1.rotate(-2*deg*n/n2) # 囓合點往右偏 pr2/2 即為 n2 齒輪的圓心 x 座標, 且 n2 齒轉 180 加一齒角度後囓合 cgo.render(gear1, {'x':cx, 'y':cy, 'scl':reduced_ratio, 'degs':180+(360/n2/2)}) set_interval(draw, 2)","tags":"Course","url":"./3.html"},{"title":"2018 協同產品設計齒輪練習","text":"50t 與 25t 的齒輪嚙合靜態輪廓圖 window.onload=function(){ brython(1); } # 將 導入的 document 設為 doc 主要原因在於與舊程式碼相容 from browser import document as doc # 由於 Python3 與 Javascript 程式碼已經不再混用, 因此來自 Javascript 的變數, 必須居中透過 window 物件轉換 from browser import window # 針對 Javascript 既有的物件, 則必須透過 JSConstructor 轉換 from javascript import JSConstructor import math # 主要用來取得畫布大小 canvas = doc[\"gear1\"] # 此程式採用 Cango Javascript 程式庫繪圖, 因此無需 ctx #ctx = canvas.getContext(\"2d\") # 針對類別的轉換, 將 Cango.js 中的 Cango 物件轉為 Python cango 物件 cango = JSConstructor(window.Cango) # 針對變數的轉換, shapeDefs 在 Cango 中資料型別為變數, 可以透過 window 轉換 shapedefs = window.shapeDefs # 目前 Cango 結合 Animation 在 Brython 尚無法運作, 此刻只能繪製靜態圖形 # in CangoAnimation.js #interpolate1 = window.interpolate # Cobi 與 createGearTooth 都是 Cango Javascript 程式庫中的物件 cobj = JSConstructor(window.Cobj) creategeartooth = JSConstructor(window.createGearTooth) # 經由 Cango 轉換成 Brython 的 cango, 指定將圖畫在 id=\"plotarea\" 的 canvas 上 cgo = cango(\"gear1\") ###################################### # 畫正齒輪輪廓 ##################################### def spur(cx, cy, m, n, pa, theta): # n 為齒數 #n = 50 # pa 為壓力角 #pa = 25 # m 為模數, 根據畫布的寬度, 計算適合的模數大小 # Module = mm of pitch diameter per tooth #m = 0.8*canvas.width/n # pr 為節圓半徑 pr = n*m/2 # gear Pitch radius # generate gear data = creategeartooth(m, n, pa) # Brython 程式中的 print 會將資料印在 Browser 的 console 區 #print(data) gearTooth = cobj(data, \"SHAPE\", { \"fillColor\":\"#ddd0dd\", \"border\": True, \"strokeColor\": \"#606060\" }) #gearTooth.rotate(180/n) # rotate gear 1/2 tooth to mesh, 請注意 rotate 角度為 degree # theta 為角度 gearTooth.rotate(theta) # 單齒的齒形資料經過旋轉後, 將資料複製到 gear 物件中 gear = gearTooth.dup() # gear 為單一齒的輪廓資料 #cgo.render(gearTooth) # 利用單齒輪廓旋轉, 產生整個正齒輪外形 for i in range(1, n): # 將 gearTooth 中的資料複製到 newTooth newTooth = gearTooth.dup() # 配合迴圈, newTooth 的齒形資料進行旋轉, 然後利用 appendPath 方法, 將資料併入 gear newTooth.rotate(360*i/n) # appendPath 為 Cango 程式庫中的方法, 第二個變數為 True, 表示要刪除最前頭的 Move to SVG Path 標註符號 gear.appendPath(newTooth, True) # trim move command = True # 建立軸孔 # add axle hole, hr 為 hole radius hr = 0.6*pr # diameter of gear shaft shaft = cobj(shapedefs.circle(hr), \"PATH\") shaft.revWinding() gear.appendPath(shaft) # retain the 'moveTo' command for shaft sub path gear.translate(cx, cy) # render 繪出靜態正齒輪輪廓 cgo.render(gear) # 接著繪製齒輪的基準線 deg = math.pi/180 Line = cobj(['M', cx, cy, 'L', cx+pr*math.cos(theta*deg), cy+pr*math.sin(theta*deg)], \"PATH\", { 'strokeColor':'blue', 'lineWidth': 1}) cgo.render(Line) # 3個齒輪的齒數 n1 = 50 n2 = 25 # m 為模數, 根據畫布的寬度, 計算適合的模數大小 # Module = mm of pitch diameter per tooth # 利用 80% 的畫布寬度進行繪圖 # 計算模數的對應尺寸 m = canvas.width*0.8/(n1+n2) # 根據齒數與模組計算各齒輪的節圓半徑 pr1 = n1*m/2 pr2 = n2*m/2 # 畫布左右兩側都保留畫布寬度的 10% # 依此計算對應的最左邊齒輪的軸心座標 cx = canvas.width*0.1+pr1 cy = canvas.height/2 # pa 為壓力角 pa = 25 # 畫最左邊齒輪, 定位線旋轉角為 0, 軸心座標 (cx, cy) spur(cx, cy, m, n1, pa, 0) # 第2個齒輪將原始的定位線逆時鐘轉 180 度後, 與第1個齒輪正好齒頂與齒頂對齊 # 只要第2個齒輪再逆時鐘或順時鐘轉動半齒的角度, 即可完成囓合 # 每一個齒分別包括從齒根到齒頂的範圍, 涵蓋角度為 360/n, 因此所謂的半齒角度為 180/n spur(cx+pr1+pr2, cy, m, n2, pa, 180-180/n2) # 第2齒與第3齒的囓合, 首先假定第2齒的定位線在 theta 角為 0 的原始位置 # 如此, 第3齒只要逆時鐘旋轉 180 度後, 再逆時鐘或順時鐘轉動半齒的角度, 即可與第2齒囓合 # 但是第2齒為了與第一齒囓合時, 已經從原始定位線轉了 180-180/n2 度 # 而當第2齒從與第3齒囓合的定位線, 逆時鐘旋轉 180-180/n2 角度後, 原先囓合的第3齒必須要再配合旋轉 (180-180/n2 )*n2/n3","tags":"Course","url":"./2.html"},{"title":"2018 協同產品設計齒輪練習","text":"網際齒輪練習 利用漸開線原理, 以 Brython 繪製單一正齒輪廓:21齒 window.onload=function(){ // 設定 data/py 為共用程式路徑 brython({debug:1, pythonpath:['./../data/py']}); } from browser import document as doc import math # deg 為角度轉為徑度的轉換因子 deg = math.pi/180. # 定義 Spur 類別 class Spur(object): def __init__(self, ctx): self.ctx = ctx def create_line(self, x1, y1, x2, y2, width=3, fill=\"red\"): self.ctx.beginPath() self.ctx.lineWidth = width self.ctx.moveTo(x1, y1) self.ctx.lineTo(x2, y2) self.ctx.strokeStyle = fill self.ctx.stroke() # # 定義一個繪正齒輪的繪圖函式 # midx 為齒輪圓心 x 座標 # midy 為齒輪圓心 y 座標 # rp 為節圓半徑, n 為齒數 # pa 為壓力角 (deg) # rot 為旋轉角 (deg) # 已經針對 n 大於等於 52 齒時的繪圖錯誤修正, 因為 base circle 與齒根圓大小必須進行判斷 def Gear(self, midx, midy, rp, n=20, pa=20, color=\"black\"): # 齒輪漸開線分成 15 線段繪製 imax = 15 # 在輸入的畫布上繪製直線, 由圓心到節圓 y 軸頂點畫一直線 self.create_line(midx, midy, midx, midy-rp) # 畫出 rp 圓, 畫圓函式尚未定義 #create_oval(midx-rp, midy-rp, midx+rp, midy+rp, width=2) # a 為模數 (代表公制中齒的大小), 模數為節圓直徑(稱為節徑)除以齒數 # 模數也就是齒冠大小 a=2*rp/n # d 為齒根大小, 為模數的 1.157 或 1.25倍, 這裡採 1.25 倍 d=2.5*rp/n # ra 為齒輪的外圍半徑 ra=rp+a # 畫出 ra 圓, 畫圓函式尚未定義 #create_oval(midx-ra, midy-ra, midx+ra, midy+ra, width=1) # rb 則為齒輪的基圓半徑 # 基圓為漸開線長齒之基準圓 rb=rp*math.cos(pa*deg) # 畫出 rb 圓 (基圓), 畫圓函式尚未定義 #create_oval(midx-rb, midy-rb, midx+rb, midy+rb, width=1) # rd 為齒根圓半徑 rd=rp-d # 當 rd 大於 rb 時, 漸開線並非畫至 rb, 而是 rd # 畫出 rd 圓 (齒根圓), 畫圓函式尚未定義 #create_oval(midx-rd, midy-rd, midx+rd, midy+rd, width=1) # dr 則為基圓到齒頂圓半徑分成 imax 段後的每段半徑增量大小 # 將圓弧分成 imax 段來繪製漸開線 # 當 rd 大於 rb 時, 漸開線並非畫至 rb, 而是 rd if rd>rb: dr = (ra-rd)/imax else: dr=(ra-rb)/imax # tan(pa*deg)-pa*deg 為漸開線函數 sigma=math.pi/(2*n)+math.tan(pa*deg)-pa*deg for j in range(n): ang=-2.*j*math.pi/n+sigma ang2=2.*j*math.pi/n+sigma lxd=midx+rd*math.sin(ang2-2.*math.pi/n) lyd=midy-rd*math.cos(ang2-2.*math.pi/n) for i in range(imax+1): # 當 rd 大於 rb 時, 漸開線並非畫至 rb, 而是 rd if rd>rb: r=rd+i*dr else: r=rb+i*dr theta=math.sqrt((r*r)/(rb*rb)-1.) alpha=theta-math.atan(theta) xpt=r*math.sin(alpha-ang) ypt=r*math.cos(alpha-ang) xd=rd*math.sin(-ang) yd=rd*math.cos(-ang) # i=0 時, 繪線起點由齒根圓上的點, 作為起點 if(i==0): last_x = midx+xd last_y = midy-yd # 由左側齒根圓作為起點, 除第一點 (xd,yd) 齒根圓上的起點外, 其餘的 (xpt,ypt)則為漸開線上的分段點 self.create_line((midx+xpt),(midy-ypt),(last_x),(last_y),fill=color) # 最後一點, 則為齒頂圓 if(i==imax): lfx=midx+xpt lfy=midy-ypt last_x = midx+xpt last_y = midy-ypt # the line from last end of dedendum point to the recent # end of dedendum point # lxd 為齒根圓上的左側 x 座標, lyd 則為 y 座標 # 下列為齒根圓上用來近似圓弧的直線 self.create_line((lxd),(lyd),(midx+xd),(midy-yd),fill=color) for i in range(imax+1): # 當 rd 大於 rb 時, 漸開線並非畫至 rb, 而是 rd if rd>rb: r=rd+i*dr else: r=rb+i*dr theta=math.sqrt((r*r)/(rb*rb)-1.) alpha=theta-math.atan(theta) xpt=r*math.sin(ang2-alpha) ypt=r*math.cos(ang2-alpha) xd=rd*math.sin(ang2) yd=rd*math.cos(ang2) # i=0 時, 繪線起點由齒根圓上的點, 作為起點 if(i==0): last_x = midx+xd last_y = midy-yd # 由右側齒根圓作為起點, 除第一點 (xd,yd) 齒根圓上的起點外, 其餘的 (xpt,ypt)則為漸開線上的分段點 self.create_line((midx+xpt),(midy-ypt),(last_x),(last_y),fill=color) # 最後一點, 則為齒頂圓 if(i==imax): rfx=midx+xpt rfy=midy-ypt last_x = midx+xpt last_y = midy-ypt # lfx 為齒頂圓上的左側 x 座標, lfy 則為 y 座標 # 下列為齒頂圓上用來近似圓弧的直線 self.create_line(lfx,lfy,rfx,rfy,fill=color) canvas = doc['onegear'] ctx = canvas.getContext(\"2d\") x = (canvas.width)/2 y = (canvas.height)/2 r = 0.8*(canvas.height/2) # 齒數 n = 21 # 壓力角 pa = 20 Spur(ctx).Gear(x, y, r, n, pa, \"blue\") # 將 導入的 document 設為 doc 主要原因在於與舊程式碼相容 from browser import document as doc # 由於 Python3 與 Javascript 程式碼已經不再混用, 因此來自 Javascript 的變數, 必須居中透過 window 物件轉換 from browser import window import math # 主要用來取得畫布大小 canvas = doc[\"cango_gear\"] # 此程式採用 Cango Javascript 程式庫繪圖, 因此無需 ctx #ctx = canvas.getContext(\"2d\") cango = window.Cango.new # 針對變數的轉換, shapeDefs 在 Cango 中資料型別為變數, 可以透過 window 轉換 shapedefs = window.shapeDefs # 目前 Cango 結合 Animation 在 Brython 尚無法運作, 此刻只能繪製靜態圖形 # in CangoAnimation.js #interpolate1 = window.interpolate # Cobi 與 createGearTooth 都是 Cango Javascript 程式庫中的物件 cobj = window.Cobj.new creategeartooth = window.createGearTooth.new # 經由 Cango 轉換成 Brython 的 cango, 指定將圖畫在 id=\"cango_gear\" 的 canvas 上 cgo = cango(\"cango_gear\") ###################################### # 畫正齒輪輪廓 ##################################### # n 為齒數 n = 11 # pa 為壓力角 pa = 25 # m 為模數, 根據畫布的寬度, 計算適合的模數大小 # Module = mm of pitch diameter per tooth m = 0.8*canvas.width/n # pr 為節圓半徑 pr = n*m/2 # gear Pitch radius # generate gear data = creategeartooth(m, n, pa) # Brython 程式中的 print 會將資料印在 Browser 的 console 區 #print(data) gearTooth = cobj(data, \"SHAPE\", { \"fillColor\":\"#ddd0dd\", \"border\": True, \"strokeColor\": \"#606060\" }) gearTooth.rotate(180/n) # rotate gear 1/2 tooth to mesh # 單齒的齒形資料經過旋轉後, 將資料複製到 gear 物件中 gear = gearTooth.dup() # gear 為單一齒的輪廓資料 #cgo.render(gearTooth) # 利用單齒輪廓旋轉, 產生整個正齒輪外形 for i in range(1, n): # 將 gearTooth 中的資料複製到 newTooth newTooth = gearTooth.dup() # 配合迴圈, newTooth 的齒形資料進行旋轉, 然後利用 appendPath 方法, 將資料併入 gear newTooth.rotate(360*i/n) # appendPath 為 Cango 程式庫中的方法, 第二個變數為 True, 表示要刪除最前頭的 Move to SVG Path 標註符號 gear.appendPath(newTooth, True) # trim move command = True # 建立軸孔 # add axle hole, hr 為 hole radius hr = 0.6*pr # diameter of gear shaft shaft = cobj(shapedefs.circle(hr), \"PATH\") shaft.revWinding() gear.appendPath(shaft) # retain the 'moveTo' command for shaft sub path cx = canvas.width/2 cy = canvas.height/2 gear.translate(cx, cy) # render 繪出靜態正齒輪輪廓 cgo.render(gear)","tags":"Course","url":"./1.html"},{"title":"2017 Fall CADP 電腦輔助設計實習期末個人簡報","text":"電腦輔助設計實習期末個人簡報issue 學號: 40523135 個人簡報影片:[https://youtu.be/qLwSXiqCDuA] 分組報告: 第6 組 - [https://github.com/s40523125/ag6_cadp_finalproject/blob/gh-pages/report/latex/pdf/report.pdf] 個人課程心得:在這門課我學會了如何使用電腦軟體去實體設計一個東西，設計并不是隨便畫個圖就可以做好的。從一開始solvespace中設計提球機構的初步模型，到onshape中畫出機構，到把機構放入vrep中進行模擬。都會遇到許多實際操作中的問題，也學會了在遇到問題的時候去思考或者詢問他人如何解決之類的問題。雖然最後機構模擬完成后時間太緊失去了3D列印機構的機會，但是之後會抓緊這類的機會去實做一下。也會把遇到的問題記錄下來。","tags":"Course","url":"./2018-fall-cadp-w5.html"},{"title":"2017 Fall CADP 電腦輔助設計實習期末個人驗收","text":"電腦輔助設計實習期末個人驗收issue 學號: 40523135 個人驗收影片: [https://youtu.be/ZR_bR-pMbC8] 個人心得: 模擬的時候要把物體的干涉和動力打開，設置軸的時候要整理好零件之間的關係（類似樹枝網路）但是我還是不會如何將底下的軸設置為彈簧，讓他可以把落下來的小球彈上去。","tags":"Course","url":"./2018-fall-cadp-w4.html"},{"title":"2017 Fall CADP 電腦輔助設計個人第16周","text":"電腦輔助設計實習第16周學習彈珠機模擬的視頻 這是我設計的彈珠機模擬的視頻","tags":"Course","url":"./2018-fall-cadp-w3.html"},{"title":"2017 Fall CADP 電腦輔助設計個人ONSHAPE分配任務","text":"電腦輔助設計實習學習onshape的視頻 我分到的onshape學習視頻是有關beam零件的製作和近端文件檔案傳送到onshape上 1.beam零件製作 先從功能表中找出beam功能添加到任務欄，再畫一個綫結構，就可以在綫結構上畫出beam了 2.文件導入 點擊導入按鈕，選擇你要導入的文件然後點擊上傳，再選擇尺寸就好了","tags":"Course","url":"./2017-fall-cadp-w17.html"},{"title":"2017 Fall CADP 電腦輔助設計實習期末總結","text":"電腦輔助設計實習期末總結 本學期的主要學習目的是做出一個鋼球擡升機構與軌道，利用電腦輔助軟體設計出我們的機構，然後 利用3D列印製作出小組最後的實體。在期中以前我們學習了很多的電腦輔助的軟體onshape，fossil， github，solvespeace。 onshape可以在雲端進行繪圖無需在電腦中安裝繪圖軟體衹要有網路就好了，fossil可以很好的做到倉儲 管理協同的工作但它需要一個近端的實體主機(自己建立的伺服器)，solvespeace是一個衹有6MB的小軟體它是一個近端的繪圖軟體它十分的輕便好用。github也是一個倉儲管理的工具但不同與fossil的是它是一個遠端的倉儲由一個公司來管理，他有更完善的功能，也可以讓訪問倉儲的人與建立倉儲的人可以溝通發現問題（就比如老師和學生，我們可以在老師的issue上留言並與老師交流）。 期中以後就開始了機構的設計，一開始先去youtube上看別人的marble machine來找尋靈感。找到大致的 方向后，先用solvespeace來畫出簡化結構來模擬機構的作動，然後使用onshape來畫出機構零件並組裝 這些都完成以後小組就把onshape的檔案轉成STL檔案並放入vrep中進行模擬。但是我們在vrep中遇到了許多的問題。比如小組機構最初設計的時候沒有設計零件之間是沒有誤差的所以在模擬的時候每一個階梯就不會正常的往下落而是每個階梯都在碰撞。所以就給了零件之間0.2mm的工差。但是發現好像沒有解決問題。最後通過改動dynamic中的碰撞數據xyz軸都改成1.然後第一個階梯就可以開始運動了。當開啓 第6個階梯的時候又出現了問題它又開始碰撞。所以可能是後面兩塊接觸面積大給的0.2mm的工差不夠。 就把後面兩塊階梯改成0.3mm的貼合距離。之後碰到的問題主要都是小組個人軌道接合的問題。 以下是我的個人簡報視頻。 這是我的小組機構的模擬視頻","tags":"Course","url":"./2018-fall-cadp-w2.html"},{"title":"2017 Fall CADP 電腦輔助設計實習第15周學習心得","text":"電腦輔助設計實習第15週 元旦快樂！ 因爲那個干涉解決不了，所以我們小組決定更換升球機構。改成用階梯式的升球機構來作爲我們的 機構。 階梯式的機構靈感也是來源於youtube視頻[https://www.youtube.com/watch?v=2I_3mFmrU4A&t=47s] 選擇馬達帶動底部凸輪結構，再通過凸輪的往復運動來達到階梯上下交錯的功能。 所以想好之後就開始畫圖，我們組使用的軟體是soildworks，因爲他的功能比較强大可以在機構組合完成后製作動畫，而且它會考慮工件之間的干涉。衹要把馬達參數設定完成后，你的機構就會開始活動起來，可以看到初步的效果。 soildworks初步效果的視頻","tags":"Course","url":"./2018-fall-cadp-w1.html"},{"title":"2017 Fall CADP 電腦輔助設計實習第13周學習心得","text":"電腦輔助設計實習第13週 小組在機構綫結構的模擬上出現了一個難題 就是我們的機構需要在左邊的桿件到達頂端的時候與 中間桿件上的一根柱子做干涉碰撞，要達到這個效果十分的困難。在solvespeace和onshape中都沒有 這個干涉碰撞的選項，導致我們的機構目前都達不到我們理想的效果。沒法實現我們機構的製作。","tags":"Course","url":"./2017-fall-cadp-w13.html"},{"title":"2017 Fall CADP 電腦輔助設計實習第12周學習心得","text":"電腦輔助設計實習第12週 期中考試過後就開始設計小組的升球機構，小組經過討論過後決定采用一種豎直的階梯結構 通過左右階梯的上下搖擺來使小球從地處被運送至高處。 小組的靈感來自於youtube上有關marble machine的一個視頻 所以我們決定先在solves peace上先畫出綫的結構然後再設計主要機構以及運球軌道。","tags":"Course","url":"./2017-fall-cadp-w12.html"},{"title":"2017 Fall CADP 電腦輔助設計個人第11周","text":"電腦輔助設計實習第11周小組機構設計要求 這周是統計小組設計機構的設計要求： 其中, 連桿機構零組件可以採用系上既有的 Solvespace、Onshape、Dassault Solidworks、AutoDesk Inventor、AutoDesk A360 或 PTC Creo 繪製, 機構與鋼球運動模擬可以採用 V-rep 或 Blender 進行, 控制 V-rep 模擬系統的外部程式套件, 可以採用 Python3 remote API 架構完成, 電子系統可以採用 AutoDesk TinkerCAD 模擬, 用來記錄鋼球通過關鍵點次數, 以及鋼球運動總距離及總爬升高度的資訊系統, 則可以採用 Python3 以及 PyQt5 建置, 而主要機構零組件則可以採系上既有的 3D 印表機組列印. 各組所完成的\"機電資整合鋼球運動系統\", 必須包含一個主要的鋼球運送機構模組 (以下稱為主模組), 並且能夠納入各學員所完成的軌道機構模組 (以下稱為軌道模組), 進行循環運動, 且整體系統的尺寸必須能夠放入郵局 Box2 紙箱中(規格: 23×18×19(cm). 當各組開始啟動\"機電資整合鋼球運動系統\"專題製作時, 各學員必須將所有細節紀錄在 二甲 與 二乙 所分配到的 Fossil SCM 伺服器主機中, 且各學員在近端隨身碟必須自行保全所有與專題相關的資料, 專題完成後, 再將各學員的 Fossil SCM 倉儲同步到 Github 倉儲. 各班依照座位, 前後三人共六人為一小組, 必須完成一套主模組設計, 各學員則分別提供一組軌道模組配合, 進行循環運動模擬. 第十三週起則每三小組合併成一大組, 根據學員投票決定實作一組主模組, 各學員則必須實作一組軌道系統與主模組配合運作. 最後各大組以協同方式完成電腦輔助設計實習報告, 各學員則根據所參與內容, 完成個人期末報告, 分別以 Reveal.js 網際簡報、Pelican 網誌、Vimeo 與 Youtube 影片呈現.","tags":"Course","url":"./2017-fall-cadp-w11.html"},{"title":"2017 Fall CADP 電腦輔助設計個人第10周","text":"電腦輔助設計實習第10周小組機構設計可用軟件 期中過後就要開始設計小組的提球機構，我們可以使用soildworks，autodesk，ptc creo，等軟體來輔助我們設計機構。這些正版軟體我們可以從教室電腦進行下載.相關内容可以在老師fossil裏找到[https://mde1a1.kmol.info/2017fall/index] 而且每周四的晚上7.30到9.30在電腦輔助設計教室會有助教幫忙解決問題。","tags":"Course","url":"./2017-fall-cadp-w10.html"},{"title":"2017 Fall CADP 電腦輔助設計個人ONSHAPE分配任務第9周任務","text":"電腦輔助設計實習第九周（學習onshape的視頻） 我分到的onshape學習視頻是有關beam零件的製作和近端文件檔案傳送到onshape上 1.beam零件製作 先從功能表中找出beam功能添加到任務欄，再畫一個綫結構，就可以在綫結構上畫出beam了 2.文件導入 點擊導入按鈕，選擇你要導入的文件然後點擊上傳，再選擇尺寸就好了","tags":"Course","url":"./2017-fall-cadp-w9.html"},{"title":"2017 Fall CADP 電腦輔助設計實習第八週學習心得","text":"電腦輔助設計實習第八週期中总结 本学期要做的是一个机电整合的轨道所以需要学员们有设计的表达，模拟设计产品，和小组成员互动，实际制作产品的能力 上半个学期主要的任务是 1.学会如何使用Fossil SCM作为自己的仓储做到将数据进行上传，下载和改动（包括制作课程网志） 2.使用solve space绘制简单零组件Nutcracker 并在solve space进行组装（solve space主要用处是可以在设计的时候进行系统机构的原型概念设计） 3.使用OnShape云端进行小组协同细部设计（OnShape的好处是可以在云端进行绘图与小组协同绘图） 4.设计完成的组件可以在V-REP中进行模拟观察组件的模拟结果可以知道缺陷并进行改动 所以我将针对以上几点进行我的汇报 期中报告的影片： 期中自评根据 fossil网志[https://cadpa.kmol.info/40523135/doc/trunk/blog/] onshape上组装的组件[https://cad.onshape.com/documents/65744a6e2b32184e98c3065f/w/509279665cf45df99d561001/e/53112a729705d889b13834ac] youtube的影片[https://www.youtube.com/channel/UCHh3rZnx8q6607BBAAGF_DQ?view_as=subscriber]","tags":"Course","url":"./2017-fall-cadp-w8-1.html"},{"title":"2017 Fall CADP 電腦輔助設計實習第七週學習心得","text":"電腦輔助設計實習第七週學習心得 本周的心得就是solvespeace的使用 和v-rep的使用 在solvespeace中要使用各种的约束条件来完成零件的组装 约束条件有To start the line, left-click. To end the line, left click again（点击line再点图面画出直线） stop drawing by pressing Escape, or by right-clicking. 想要停下画图就点击鼠标右键 Constrain → On Point / Curve / Plane to constrain point-on-point点和点重合 The H appears in yellow if we hover the mouse over it添加水平限制条件 Constrain → Parallel / Tangent平行 Constrain → Equal Length / Radius / Angle等长 Sketch → Tangent Arc at Point选择一个点然后画切点弧 Edit → Undo消除线 New Group → Extrude新的作图面 extrude on both sides两端生长 Constrain → On Curve开线 ###考试影片 第一步建立网志 第二步画出板件 第三步 零件组装 期中自评根据 fossil网志[https://cadpa.kmol.info/40523135/doc/trunk/blog/] onshape上组装的组件[https://cad.onshape.com/documents/65744a6e2b32184e98c3065f/w/509279665cf45df99d561001/e/53112a729705d889b13834ac] youtube的影片[https://www.youtube.com/channel/UCHh3rZnx8q6607BBAAGF_DQ?view_as=subscriber]","tags":"Course","url":"./2017-fall-cadp-w7-2.html"},{"title":"2017 Fall CADP 第6週上课内容","text":"2017fall cadpa w6 第6周课程网网志 上课任务 整理影片内容写心得 问题：这张杆件的设计图是英制的我在画图的时候没有注意所以我要重新转档改为英制然后重新定尺寸 第二个问题是solvespeace可能是有BUG它有时无法正确的表示我们所定的特征 修改公制影片 修改完成后的stl档 回去以后的工作：试着将零件组合 还有在onshape上绘图 如果想要字体大一点的话可以在leo档中文字的前面加三个英文减号","tags":"Course","url":"./2017-fall-cadp-w7.html"},{"title":"2017 Fall CADP 第6週","text":"2017fall cadpa w 第6周课程网网志 本周练习为了展示在solvespace中所画的连杆结构 BASE的画图影片 base的stl档 cylinder的绘图影片 cylinder的stl档 hinge的绘图影片 hinge的stl档 piston的绘图影片 piston的STL档 adjuster_base的绘图影片 adjuster_base的STL档 adjuster的绘图影片 adjuster的stl档 connection的绘图影片 connection的STL档 handle的绘图影片 handle的STL档","tags":"Course","url":"./2017-fall-cadp-w6.html"},{"title":"2017 Fall CADP 第5週","text":"2017fall cadpa w5 第五周课程网网志 课程主要目的：做出实体的组件来让小球可以运动 所以准备工作就是先在电脑上模拟出组件的外型，以及小球在组件上的运动情况 这门课程是以小组为单位所以要有一个可以在网路上协同工作的仓储，本学期所用的仓储 是fossil fossil可以让组员连接主机并对数据进行更改。当有了仓储以后组员就要用电脑绘图程式 来绘出组件的3d模型。可以用solvespace 来绘图 solvespace的优势是软件小 使用方便也可以绘出想要的文件 组件画好以后转成.stl格式然后放入V-rep来模拟小球在组件上的运动情况。 当模拟成功后加以改进就可以进行实体的组件制作。","tags":"Course","url":"./2017-fall-cadp-w5.html"},{"title":"2017 Fall CADP 第4週","text":"2017fall cadpa w4 第四周课程网网志 【https://cadpa.kmol.info/40523135/doc/trunk/blog/】 1.遇到的问题是我的网志上传之后点开blog 连接不上我自己的主机所以是远端网址错误导致的 把主机改成cadpa 2017fall改为学号40523135 2.主要的目的是使用 solvespace v-rep绘图","tags":"Course","url":"./2017-fall-cadp-w4.html"},{"title":"2017 Fall CADP 第二週","text":"本學期起各班透過一台 Ubuntu 16.04 主機, 建立 Fossil SCM 伺服器, 且每一學員發放一個 Fossil SCM 倉儲, 其中各學員可以利用 Wiki 與 Technote 紀錄學習資料外, 還可以將靜態網誌與簡報檔案放入 Files 資料區. 希望為每位學員建立倉儲的設想流程如下: 各學員可以獨立維護倉儲內容, 也可以在總管理員的權限下, 為分組學員建立帳號, 逐步導入協同設計 各學員的倉儲以修課班級命名伺服器, 以學號命名倉儲, 方便依照此一規律擷取各學員的倉儲頁面. 各學員能以電子郵件收到與新建倉儲相關的連結, 以及帳號密碼. 必須擴增 Ubuntu ulimits -n 同時開檔的設限範圍 (內定只允許同時開啟 1024 個檔案) 解決方案: 主機名稱可以透過 domain dns 中的 CNAME 別名方式處理, 因為目前所能提供出來的 IPv4/IPv6 雙支援主機, 之前已經都設定了符號名稱. fossil init 雖然提供指定管理者的 -A 選項功能, 但是無法直接指定管理者對應密碼, 因此必須建立倉儲之後, 再利用 fossil user 修改密碼, 之後再利用 Gmail 寄出通知信, 其中提供倉儲連結, 登入帳號與密碼等資訊. 建立各學員倉儲檔案的程式如下, 如前所述, 主要透過兩個 Fossil SCM 指令完成, 在 Windows 採用 Fossil SCM 2.3 版建立所有 .fossil 倉儲時, 將同時以 email 通知各學員. 各學員的 .fossil 檔案再以 sftp 送到伺服主機對應帳號所屬的目錄下. 必須要特別注意的是, 採用 Fossil SCM 2.3 版所建立的 .fossil 倉儲檔案, 在 Ubuntu 操作系統上也必須採用相同版本的 fossil, 否則舊版 fossil 可能無法開啟新版 fossil 程式所建立的倉儲檔. import os import string import random # 使用 Gmail 寄信必須導入下列模組 import smtplib import re from email.mime.text import MIMEText from email.header import Header # 用來以亂數建立密碼的韓式 def id_generator(size=6, chars=string.ascii_uppercase + string.digits): ''' source: https://stackoverflow.com/questions/2257441/random-string-generation-with-upper-case-letters-and-digits-in-python ''' return ''.join(random.choice(chars) for _ in range(size)) # 讀取學員名單, 逐一取得學員學號, 學員名單, 檢查點 1/7 student_data = open(\"2017fall_list/1b.txt\").read() student_list = student_data.splitlines() # 利用 gmail smtp 功能寄信 server = smtplib.SMTP('smtp.gmail.com:587') server.ehlo() server.starttls() # 以下必須準備好對應郵件帳號與密碼的外部檔案, 所提供的寄信帳號, 是否可以寄信, 檢查點 2/7 ''' 寄信之前必須到 https://www.google.com/settings/security/lesssecureapps 修改權限, 改為較低安全權限 否則無法使用程式寄信! ''' # 從外部檔案讀取要用來寄信的 gmail 帳號與密碼 # mail.txt 格式為: 電子郵箱,對應密碼, 以逗點隔開, 檢查點 3/7 email_data = open(\"z:/2017fall/mail.txt\").read() email, email_password= email_data.split(\",\") print(email, email_password) # 是否登入所提供寄信的電子郵箱, 4/7 server.login(email, email_password) # 不同課程名稱, 與對應主機名稱, 必須配合修改 5/7 course_title = \"計算機程式\" fossil_server = \"cpb.kmol.info\" for student_num in student_list: username = student_num repository = username + '.fossil' # 利用所提供的字串, 以亂數組成六個字元的密碼 password = id_generator(6, \"23456789abcdef\") print(student_num, \", \" , password) # 執行 dos command 指令, 建立倉儲 os.system(\"fossil init -A \" +username + \" \" + repository) print(\"已經建立倉儲 \" + repository) # 執行 dos command 指令, 修改使用者密碼 os.system(\"fossil user password \" + username + \" \" + password + \" -R \" + repository) print(\"已經修改密碼\") # 利用 Gmail 寄信, 告知各學員倉儲連結與帳號密碼 # 每一位學員收到的 output 都從這裡 reset output = \"\" # 若學號欄為空, 則不寄信 if student_num != \"\": # output 為寄給每一位學員的資料表格 mail_content = student_num+' 您好: 您在 '+course_title+' 課程中的區域網路倉儲: https://'+fossil_server+'/'+student_num+' ' mail_content += '管理帳號為:'+ student_num + ' 管理密碼為: '+ password+' ' print(student_num) print(mail_content) # 至此 mail_content 已經確定 # 在測試與實際寄送資料, 也必須配合修改, 檢查點 6/7 receiver_email = student_num + \"@gm.nfu.edu.tw\" # 測試用 #receiver_email = student_num+\"@mde.tw\" # 列出收信人 email 位址 #print(receiver_email) #message= MIMEText(mail_content,'plain','UTF-8') # 以 html 格式寄信 message= MIMEText(mail_content,'html','UTF-8') message['Subject'] = Header(course_title+\" Fossil SCM 帳號通知\", 'UTF-8') # 可以先不寄信, 確定格式正確後再開啟, 是否實際寄出信件, 檢查點 7/7 server.sendmail(\"gmail_address\", receiver_email, message.as_string()) server.quit() 各班所完成的主機: 二甲電腦輔助設計實習: https://cadpa.kmol.info 二乙電腦輔助設計實習: https://cadpb.kmol.info 一甲計算機程式: https://cpa.kmol.info 一乙計算機程式: https://cpb.kmol.info","tags":"Course","url":"./2017-fall-cadp-w2.html"}]}